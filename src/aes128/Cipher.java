package aes128;

import static aes128.S_box.*;
import java.util.Arrays;

/**
 * @author RanYunlong
 * @author Kingteeloki ZJU 2019.6.17
 */
public class Cipher {

    /*
	 * Rcon also should be generated by finite field multiplication
	 * for simple here i list it directly, this Rcon also surpport 
	 * AES-192 or AES-256.
     */
    private static final byte[][] Rcon = {
        {0x00, 0x00, 0x00, 0x00},
        {0x01, 0x00, 0x00, 0x00},
        {0x02, 0x00, 0x00, 0x00},
        {0x04, 0x00, 0x00, 0x00},
        {0x08, 0x00, 0x00, 0x00},
        {0x10, 0x00, 0x00, 0x00},
        {0x20, 0x00, 0x00, 0x00},
        {0x40, 0x00, 0x00, 0x00},
        {(byte) 0x80, 0x00, 0x00, 0x00},
        {(byte) 0x1b, 0x00, 0x00, 0x00},
        {(byte) 0x36, 0x00, 0x00, 0x00}};

    public int Nb;			//indicate number of blocks.
    public int Nk;			//indicate number of key words(one word indicate 4 bytes).
    public int Nr;			//indicate number of round the algorithm should implement.
    private byte[][] w;		//expanded key.
    private int[] s_box_one_dime;		//s_box which used for substitution.
    private S_box sboxgenerator;		//generator can generate s_box, see details in class S_box.

    // constructor with no parameter.
    public Cipher() {
        // TODO Auto-generated constructor stub
        Nb = 4;
        Nk = 4;
        Nr = 10;
        w = new byte[Nb * (Nr + 1)][Nb];
        sboxgenerator = new S_box();
        s_box_one_dime = sboxgenerator.generate_one_dime();
    }

    /**
     * Encrypt a block state. if you don't want to print middle result please
     * encryptstate(byte[][] state)
     *
     * @param state the 4x4 byte[][] state you want to encrypt.
     * @return encrypted state.
     */
    public byte[][] encryptstate(byte[][] state) {
        System.out.println("Begin to encrypt state!!!");
        System.out.println("input:");
        printstate(state);

        SubBytes(state);
        System.out.println("after subbytes:");
        printstate(state);

        state = ShiftRows(state);
        System.out.println("after shiftrows:");
        printstate(state);

        state = MixColumns(state);
        System.out.println("after mixcolumns:");
        printstate(state);
//        AddRoundKey(0, state);
//        for (int i = 1; i < Nr; i++) {
//            System.out.println("start of round " + i + ":");
//            printstate(state);
//            SubBytes(state);
//            System.out.println("after subbytes:");
//            printstate(state);
//
//            state = ShiftRows(state);
//            System.out.println("after shiftrows:");
//            printstate(state);
//
//            state = MixColumns(state);
//            System.out.println("after mixcolumns:");
//            printstate(state);
//
//            AddRoundKey(i, state);
//            System.out.println("after round key:");
//            printstate(state);
//        }
//        System.out.println("start of round " + Nr + ":");

//        AddRoundKey(Nr, state);
//        System.out.println("output:");
        return state;
    }

    /**
     * transfer a byte[][] state to string type.
     *
     * @param state the 4x4 byte[][] state you want to transfer.
     * @return a string represent the state bytes
     */
    private String statetostring(byte[][] state) {
        StringBuilder stringBuilder = new StringBuilder();
        for (int i = 0; i < 4; i++) {
            for (int j = 0; j < 4; j++) {
                stringBuilder.append(String.format("%02X", state[j][i]));
            }
        }
        String string = stringBuilder.toString();
        return string;
    }

    /**
     * do substitution using s_box.
     *
     * @param state the 4x4 byte[][] state you want to substitute.
     * @return the substituted state
     */
    private void SubBytes(byte[][] state) {
        for (int i = 0; i < Nb; i++) {
            for (int j = 0; j < Nb; j++) {
                state[i][j] = (byte) (s_box_one_dime[state[i][j] & 0x00ff] & 0x00ff);
//                System.out.println("State = " + state[i][j] + " &0x00ff = " + (state[i][j] & 0x00ff) + " S_box = " + s_box_one_dime[state[i][j] & 0x00ff]);
            }
        }
    }

    /**
     * shift every row of state with specific rule,just implement this on
     * original state.
     *
     * @param state the 4x4 byte[][] state you want to make shifting rows.
     */
    private byte[][] ShiftRows(byte[][] state) {
        byte[][] tmp = new byte[Nb][Nb];
        for (int i = 0; i < Nb; i++) {
            for (int j = 0; j < Nb; j++) {
                tmp[i][j] = state[i][(Nb + i + j) % Nb];
            }
        }
        return tmp;
    }

    /**
     * mix every column of state with specific rule
     *
     * @param state the 4x4 byte[][] state you want to mix.
     * @return the mixed state
     */
    private byte[][] MixColumns(byte[][] state) {
        byte[] a = {2, 3, 1, 1};

        byte[][] tmp = new byte[Nb][Nb];
        for (int j = 0; j < Nb; j++) {
            tmp[0][j] = (byte) (mul(a[0], state[0][j]) ^ mul(a[1], state[1][j])
                    ^ mul(a[2], state[2][j]) ^ mul(a[3], state[3][j]));
            tmp[1][j] = (byte) (mul(a[3], state[0][j]) ^ mul(a[0], state[1][j])
                    ^ mul(a[1], state[2][j]) ^ mul(a[2], state[3][j]));
            tmp[2][j] = (byte) (mul(a[2], state[0][j]) ^ mul(a[3], state[1][j])
                    ^ mul(a[0], state[2][j]) ^ mul(a[1], state[3][j]));
            tmp[3][j] = (byte) (mul(a[1], state[0][j]) ^ mul(a[2], state[1][j])
                    ^ mul(a[3], state[2][j]) ^ mul(a[0], state[3][j]));
//            printstate(state);

//            System.out.println("tmp = " + Arrays.toString(tmp[j]));
        }

        return tmp;
    }

    /**
     * @param input
     * @deprecated this method is used for test.this method will transfer your
     * input text to hexadecimal characters and then encrypt them. if it fulfill
     * your requirements, you can invoke it anymore
     * @param inputkey your key which used in encryption and they will be regard
     * as hexadecimal characters.
     * @return return the encrypted string
     */
    public byte[][] encryptparsestring(String input) {
        String sb;
        int start = 0;
        int end = 2;
        byte[][] state = new byte[Nb][Nb];
        //iterate over line two chars at a time, add their hex value to matrix
        for (int i = 0; i < state.length; i++) {
            for (int j = 0; j < state[0].length; j++) {
                sb = input.substring(start, end);
                state[j][i] = (byte) (Integer.parseInt(sb, 16));
//                System.out.println(state[i][j]);
                start += 2;
                end += 2;
            }
        }
        state = encryptstate(state);
//        System.out.println(statetostring(state));
        return state;
    }

    /**
     * print state as hexadecimal characters
     *
     * @param state the 4x4 byte[][] state you want to print.
     */
    private void printstate(byte[][] state) {
        int i = 0;
        int j = 0;
        for (; i < 4; i++) {
            for (j = 0; j < 4; j++) {
                String string = String.format("%02X", state[i][j]);
                System.out.print(string + " ");
            }
            System.out.println();
        }
    }

    public static void main(String[] args) {
        // TODO Auto-generated method stub

    }

}
